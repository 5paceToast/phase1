diff --git a/src/libgcompat/alias.h b/src/libgcompat/alias.h
new file mode 100644
index 0000000..bb3b387
--- /dev/null
+++ b/src/libgcompat/alias.h
@@ -0,0 +1,9 @@
+#ifndef _ALIAS_H_
+#define _ALIAS_H_
+
+#define _GNU_SOURCE
+
+#define alias(old, new)                                                        \
+	extern __typeof(old) new __attribute__((__alias__(#old)))
+
+#endif /* _ALIAS_H_ */
diff --git a/src/libgcompat/ctype.c b/src/libgcompat/ctype.c
new file mode 100644
index 0000000..1ae9877
--- /dev/null
+++ b/src/libgcompat/ctype.c
@@ -0,0 +1 @@
+const unsigned short int *__ctype_b;
diff --git a/src/libgcompat/cxx_thread.c b/src/libgcompat/cxx_thread.c
new file mode 100644
index 0000000..105e4c5
--- /dev/null
+++ b/src/libgcompat/cxx_thread.c
@@ -0,0 +1,56 @@
+#include <pthread.h> /* NULL, pthread_{key,once,{get,set}specific} */
+#include <stdlib.h>  /* malloc, free */
+
+#include "internal.h"
+
+struct dtor_node {
+	struct dtor_node *next;
+	void (*func)(void *);
+	void *obj;
+};
+
+static pthread_key_t key;
+static pthread_once_t once = PTHREAD_ONCE_INIT;
+
+static void run_dtors(void *head)
+{
+	struct dtor_node *next, *node = head;
+
+	while (node != NULL) {
+		next = node->next;
+		node->func(node->obj);
+		free(node);
+		node = next;
+	}
+}
+
+static void create_key(void)
+{
+	int res = pthread_key_create(&key, run_dtors);
+
+	GCOMPAT__assert_with_reason(res, "No key for thread_atexit list");
+}
+
+/**
+ * Register a destructor to run at thread exit.
+ *
+ * See
+ * https://sourceware.org/glibc/wiki/Destructor%20support%20for%20thread_local%20variables
+ */
+int __cxa_thread_atexit_impl(void (*func)(void *), void *obj, void *dso_symbol)
+{
+	struct dtor_node *node;
+
+	pthread_once(&once, create_key);
+
+	node = malloc(sizeof(*node));
+	GCOMPAT__assert_with_reason(node, "No memory for thread_atexit node");
+	node->next = pthread_getspecific(key);
+	node->func = func;
+	node->obj = obj;
+
+	int res = pthread_setspecific(key, node);
+	GCOMPAT__assert_with_reason(!res, "Cannot update thread_atexit list");
+
+	return 0;
+}
diff --git a/src/libgcompat/dlfcn.c b/src/libgcompat/dlfcn.c
new file mode 100644
index 0000000..f2eaa45
--- /dev/null
+++ b/src/libgcompat/dlfcn.c
@@ -0,0 +1,25 @@
+#include <dlfcn.h>  /* dlopen, dlsym */
+#include <stddef.h> /* NULL */
+#include <stdio.h>  /* fprintf */
+#include <stdlib.h> /* getenv */
+
+void *dlmopen(long lmid, const char *pathname, int mode)
+{
+	if (getenv("GLIBC_FAKE_DEBUG") != NULL) {
+		fprintf(stderr,
+		        "loading library %s was requested in namespace %ld",
+		        pathname, lmid);
+	}
+
+	return dlopen(pathname, mode);
+}
+
+void *dlvsym(void *handle, char *symbol, char *version)
+{
+	if (getenv("GLIBC_FAKE_DEBUG") != NULL) {
+		fprintf(stderr, "symbol %s with version %s is being redirected",
+		        symbol, version);
+	}
+
+	return dlsym(handle, symbol);
+}
diff --git a/src/libgcompat/error.c b/src/libgcompat/error.c
new file mode 100644
index 0000000..c759b19
--- /dev/null
+++ b/src/libgcompat/error.c
@@ -0,0 +1,27 @@
+#define _GNU_SOURCE /* program_invocation_name */
+#include <errno.h>  /* program_invocation_name */
+#include <stdarg.h> /* va_list, va_start, va_end */
+#include <stdio.h>  /* fflush, fputc, fputs, stderr, stdout, vfprintf */
+#include <string.h> /* strerror */
+
+/**
+ * Print an error message.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib-error-n.html
+ */
+void error(int status, int errnum, const char *format, ...)
+{
+	va_list ap;
+
+	fflush(stdout);
+	fputs(program_invocation_name, stderr);
+	fputs(": ", stderr);
+	va_start(ap, format);
+	vfprintf(stderr, format, ap);
+	va_end(ap);
+	if (errnum != 0) {
+		fputs(": ", stderr);
+		fputs(strerror(errnum), stderr);
+		fputc('\n', stderr);
+	}
+}
diff --git a/src/libgcompat/execinfo.c b/src/libgcompat/execinfo.c
new file mode 100644
index 0000000..6b32f6b
--- /dev/null
+++ b/src/libgcompat/execinfo.c
@@ -0,0 +1,99 @@
+#define _GNU_SOURCE
+
+#include <dlfcn.h>  /* dladdr */
+#include <stddef.h> /* NULL */
+#include <stdint.h> /* uintptr_t */
+#include <stdlib.h> /* calloc */
+#include <string.h> /* strlen */
+#include <unistd.h> /* write */
+
+#define get_frame_level(array, size, n)                                        \
+	do {                                                                   \
+		if (n >= size || __builtin_frame_address(n) == NULL) {         \
+			return n;                                              \
+		}                                                              \
+		void *address = __builtin_return_address(n);                   \
+		array[n] = __builtin_extract_return_addr(address);             \
+		if ((uintptr_t) array[n] < 0x1000) {                           \
+			return n;                                              \
+		}                                                              \
+	} while (0)
+
+/**
+ * Obtain a backtrace for the calling program.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib-backtrace-1.html
+ */
+int backtrace(void **array, int size)
+{
+	get_frame_level(array, size, 0);
+	get_frame_level(array, size, 1);
+	get_frame_level(array, size, 2);
+	get_frame_level(array, size, 3);
+	get_frame_level(array, size, 4);
+	get_frame_level(array, size, 5);
+	get_frame_level(array, size, 6);
+	get_frame_level(array, size, 7);
+	get_frame_level(array, size, 8);
+	get_frame_level(array, size, 9);
+	return 10;
+}
+
+/**
+ * Translate addresses into symbol information.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib-backtrace-1.html
+ */
+const char **backtrace_symbols(void *const *array, int size)
+{
+	const char **result = calloc(size, sizeof(char *));
+
+	if (result == NULL) {
+		return NULL;
+	}
+	for (int i = 0; i < size; ++i) {
+		Dl_info info;
+
+		if (dladdr(array[i], &info) && info.dli_sname != NULL) {
+			result[i] = info.dli_sname;
+		} else {
+			result[i] = "??:0";
+		}
+	}
+
+	return result;
+}
+
+/**
+ * Write symbol information to a file without allocating memory.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib-backtrace-1.html
+ */
+void backtrace_symbols_fd(void *const *array, int size, int fd)
+{
+	for (int i = 0; i < size; ++i) {
+		Dl_info info;
+		const char *line;
+		int len;
+
+		if (dladdr(array[i], &info) && info.dli_sname != NULL) {
+			line = info.dli_sname;
+			len = strlen(line);
+		} else {
+			line = "??:0";
+			len = sizeof("??:0") - 1;
+		}
+		while (len > 0) {
+			int written = write(fd, line, len);
+
+			if (written < 1) {
+				return;
+			}
+			line += written;
+			len -= written;
+		}
+		if (write(fd, "\n", 1) != 1) {
+			return;
+		}
+	}
+}
diff --git a/src/libgcompat/gnulib.c b/src/libgcompat/gnulib.c
new file mode 100644
index 0000000..3f66963
--- /dev/null
+++ b/src/libgcompat/gnulib.c
@@ -0,0 +1,18 @@
+#include <sys/select.h>
+#include "internal.h"
+
+#define REASON_FD_SET_OVERFLOW                                                 \
+	"Fault: Overflow in fd_set detected.\n"                                \
+	"Description: This is caused by a programmer naively attempting to\n"  \
+	"  redefine FD_SETSIZE, which is not allowed on POSIX platforms.\n"    \
+	"  The program must either be rebuilt with the correct FD_SETSIZE\n"   \
+	"  definition, or else be rewritten to avoid use of select(2) in \n"   \
+	"  general.  See also: poll(2).\n"                                     \
+	"  libgcompat believes FD_SETSIZE to be %zu.\n"
+
+unsigned long __fdelt_chk(unsigned long size)
+{
+	GCOMPAT__assert_with_reason(size < FD_SETSIZE, REASON_FD_SET_OVERFLOW,
+	                            FD_SETSIZE);
+	return size / (sizeof(unsigned long) << 3);
+}
diff --git a/src/libgcompat/grp.c b/src/libgcompat/grp.c
new file mode 100644
index 0000000..5674fda
--- /dev/null
+++ b/src/libgcompat/grp.c
@@ -0,0 +1,98 @@
+/* some musl versions incorrectly mark fgetgrent() as a GNU extension */
+#define _GNU_SOURCE
+#include <assert.h>  /* assert */
+#include <errno.h>   /* ENOENT, ERANGE */
+#include <grp.h>     /* fgetgrent, getgrent, struct group */
+#include <pthread.h> /* pthread_mutex_* */
+#include <stddef.h>  /* NULL, size_t */
+#include <stdint.h>  /* ptrdiff_t, uintptr_t */
+#include <stdio.h>   /* FILE */
+#include <string.h>  /* memcpy, stpcpy, strlcpy, strlen */
+
+#define ALIGN_PTR_TO_SIZE_OF(ptr, type)                                        \
+	((type *) ((((uintptr_t)(ptr)) + sizeof(type) - 1)                     \
+	           & ~(sizeof(type) - 1)))
+
+static pthread_mutex_t grent_mutex = PTHREAD_MUTEX_INITIALIZER;
+
+static int __fgetgrent_r(FILE *stream, struct group *grp, char *buf, size_t len,
+                         struct group **result)
+{
+	struct group *grtmp;
+	char *cursor = buf, *end = buf + len;
+
+	*result = NULL;
+	pthread_mutex_lock(&grent_mutex);
+	grtmp = stream != NULL ? fgetgrent(stream) : getgrent();
+	if (grtmp == NULL) {
+		pthread_mutex_unlock(&grent_mutex);
+		return ENOENT;
+	}
+	memcpy(grp, grtmp, sizeof(*grp));
+	if (grtmp->gr_name != NULL) {
+		grp->gr_name = cursor;
+		cursor += strlcpy(cursor, grtmp->gr_name, end - cursor) + 1;
+		if (cursor > end) {
+			goto err_unlock;
+		}
+	}
+	if (grtmp->gr_passwd != NULL) {
+		grp->gr_passwd = cursor;
+		cursor += strlcpy(cursor, grtmp->gr_passwd, end - cursor) + 1;
+		if (cursor > end) {
+			goto err_unlock;
+		}
+	}
+	if (grtmp->gr_mem != NULL) {
+		char **members = ALIGN_PTR_TO_SIZE_OF(cursor, char *);
+		ptrdiff_t nameslen = 0;
+		size_t nmem = 0;
+
+		/* Calculate total size of strings plus their pointers. */
+		while (grtmp->gr_mem[nmem++] != NULL) {
+			nameslen += strlen(grtmp->gr_mem[nmem - 1]) + 1;
+		}
+		nameslen += nmem * sizeof(*members);
+		if (nameslen > end - ((char *) members)) {
+			goto err_unlock;
+		}
+		/* Copy the pointers, including the NULL sentinel. */
+		for (size_t i = 0; i < nmem; ++i) {
+			members[i] = grtmp->gr_mem[i];
+		}
+		/* Copy the strings (the NULL sentinel doesn't point to one). */
+		cursor = (char *) &members[nmem];
+		for (size_t i = 0; i < nmem - 1; ++i) {
+			cursor = stpcpy(cursor, members[i]) + 1;
+		}
+	}
+	pthread_mutex_unlock(&grent_mutex);
+	*result = grp;
+
+	return 0;
+
+err_unlock:
+	pthread_mutex_unlock(&grent_mutex);
+	return ERANGE;
+}
+
+/**
+ * Get group file entry.
+ */
+int fgetgrent_r(FILE *stream, struct group *grp, char *buf, size_t len,
+                struct group **result)
+{
+	assert(stream != NULL);
+
+	return __fgetgrent_r(stream, grp, buf, len, result);
+}
+
+/**
+ * Get group database entry.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib-getgrent-r-1.html
+ */
+int getgrent_r(struct group *grp, char *buf, size_t len, struct group **result)
+{
+	return __fgetgrent_r(NULL, grp, buf, len, result);
+}
diff --git a/src/libgcompat/internal.c b/src/libgcompat/internal.c
new file mode 100644
index 0000000..450c5e4
--- /dev/null
+++ b/src/libgcompat/internal.c
@@ -0,0 +1,16 @@
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+void GCOMPAT__panic(const char *fmt, ...)
+{
+	va_list va;
+
+	fprintf(stderr, "*** gcompat panic ***\n");
+
+	va_start(va, fmt);
+	vfprintf(stderr, fmt, va);
+	va_end(va);
+
+	abort();
+}
diff --git a/src/libgcompat/internal.h b/src/libgcompat/internal.h
new file mode 100644
index 0000000..a246547
--- /dev/null
+++ b/src/libgcompat/internal.h
@@ -0,0 +1,13 @@
+#ifndef LIBGCOMPAT_INTERNAL_H
+#define LIBGCOMPAT_INTERNAL_H
+
+void GCOMPAT__panic(const char *fmt, ...) __attribute__((noreturn));
+
+#define GCOMPAT__assert_with_reason(chk, ...)                                  \
+	do {                                                                   \
+		if (!(chk)) {                                                  \
+			GCOMPAT__panic(__VA_ARGS__);                           \
+		}                                                              \
+	} while (0);
+
+#endif
diff --git a/src/libgcompat/malloc.c b/src/libgcompat/malloc.c
new file mode 100644
index 0000000..510574f
--- /dev/null
+++ b/src/libgcompat/malloc.c
@@ -0,0 +1,110 @@
+/*
+ * struct mallinfo pulled from mallinfo.3:
+ *
+ * Copyright (c) 2012 by Michael Kerrisk <mtk.manpages@gmail.com>
+ *
+ * Permission is granted to make and distribute verbatim copies of this
+ * manual provided the copyright notice and this permission notice are
+ * preserved on all copies.
+ *
+ * Permission is granted to copy and distribute modified versions of this
+ * manual under the conditions for verbatim copying, provided that the
+ * entire resulting derived work is distributed under the terms of a
+ * permission notice identical to this one.
+ *
+ * Since the Linux kernel and libraries are constantly changing, this
+ * manual page may be incorrect or out-of-date.  The author(s) assume no
+ * responsibility for errors or omissions, or for damages resulting from
+ * the use of the information contained herein.  The author(s) may not
+ * have taken the same level of care in the production of this manual,
+ * which is licensed free of charge, as they might when working
+ * professionally.
+ *
+ * Formatted or processed versions of this manual, if unaccompanied by
+ * the source, must acknowledge the copyright and authors of this work.
+ */
+
+#define _GNU_SOURCE
+#include <malloc.h> /* memalign */
+#include <stdlib.h> /* {m,c,re}alloc, free */
+#include <string.h> /* memset */
+#include <unistd.h> /* sbrk */
+#include "alias.h"
+
+struct mallinfo {
+	int arena;    /* Non-mmapped space allocated (bytes) */
+	int ordblks;  /* Number of free chunks */
+	int smblks;   /* Number of free fastbin blocks */
+	int hblks;    /* Number of mmapped regions */
+	int hblkhd;   /* Space allocated in mmapped regions (bytes) */
+	int usmblks;  /* Maximum total allocated space (bytes) */
+	int fsmblks;  /* Space in freed fastbin blocks (bytes) */
+	int uordblks; /* Total allocated space (bytes) */
+	int fordblks; /* Total free space (bytes) */
+	int keepcost; /* Top-most, releasable space (bytes) */
+};
+
+void *__libc_calloc(size_t nmemb, size_t size)
+{
+	return calloc(nmemb, size);
+}
+alias(__libc_calloc, __calloc);
+
+void __libc_free(void *ptr)
+{
+	free(ptr);
+}
+alias(__libc_free, __free);
+
+void *__libc_malloc(size_t size)
+{
+	return malloc(size);
+}
+alias(__libc_malloc, __malloc);
+
+/*
+void *__libc_memalign(size_t align, size_t len)
+{
+	void *result = NULL;
+	if (posix_memalign(&result, align, len) != 0)
+		return NULL;
+	return result;
+}
+alias(__libc_memalign, __memalign);
+*/
+
+void *__libc_realloc(void *ptr, size_t size)
+{
+	return realloc(ptr, size);
+}
+alias(__libc_realloc, __realloc);
+
+void *__sbrk(intptr_t increment)
+{
+	return sbrk(increment);
+}
+
+struct mallinfo mallinfo(void)
+{
+	struct mallinfo info;
+	memset(&info, 0, sizeof(info));
+	return info;
+}
+
+int malloc_trim(size_t pad)
+{
+	/* This concept doesn't really map to musl's malloc */
+	return 0;
+}
+
+void mtrace(void)
+{
+	/* Not implemented on purpose. */
+	return;
+}
+
+void muntrace(void)
+{
+	/* Not implemented on purpose. */
+	return;
+}
diff --git a/src/libgcompat/math.c b/src/libgcompat/math.c
new file mode 100644
index 0000000..793ff1a
--- /dev/null
+++ b/src/libgcompat/math.c
@@ -0,0 +1,1181 @@
+#define _GNU_SOURCE /* Extra maths functions */
+#include <math.h>   /* Literally everything */
+
+#include "alias.h"    /* weak_alias */
+#include "internal.h" /* GCOMPAT__assert_with_reason */
+
+/**
+ * Multiplies the first argument x by FLT_RADIX (probably 2) to the power of y.
+ */
+long double scalbl(long double x, long double y)
+{
+	/*
+	 * XXX strictly not correct but:
+	 * 1) Good Enough(TM)
+	 * 2) scalbl is deprecated anyway
+	 * */
+	return scalblnl(x, (long int) y);
+}
+
+/*
+ * The below require support for ynl/jnl which doesn't exist in musl and isn't
+ * implemented in gcompat yet
+ */
+#if 0
+/**
+ * Return Bessel functions of x of the first kind of order n.
+ */
+long double jnl(int n, long double x)
+{
+	/* TODO implement */
+	return 0;
+}
+
+/**
+ * Return Bessel functions of x of the first kind of order 0.
+ */
+long double j0l(long double n)
+{
+	return jnl(0, n);
+}
+
+/**
+ * Return Bessel functions of x of the first kind of order 1.
+ */
+long double j1l(long double n)
+{
+	return jnl(1, n);
+}
+
+/**
+ * Return Bessel functions of x of the second kind of order n.
+ */
+long double ynl(int n, long double x)
+{
+	/* TODO implement */
+	return 0;
+}
+
+/**
+ * Return Bessel functions of x of the second kind of order 0.
+ */
+long double y0l(long double n)
+{
+	return ynl(0, n);
+}
+
+/**
+ * Return Bessel functions of x of the second kind of order 1.
+ */
+long double y1l(long double n)
+{
+	return ynl(1, n);
+}
+#endif
+
+/**
+ * Test for finite value.
+ */
+int __finite(double arg)
+{
+	return isfinite(arg);
+}
+weak_alias(__finite, finite);
+
+/**
+ * Test for finite value.
+ */
+int __finitef(float arg)
+{
+	return isfinite(arg);
+}
+weak_alias(__finitef, finitef);
+
+/**
+ * Test for finite value.
+ */
+int __finitel(long double arg)
+{
+	return isfinite(arg);
+}
+weak_alias(__finitel, finitel);
+
+/**
+ * Test for infinity.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---isinf.html
+ */
+int __isinf(double arg)
+{
+	return isinf(arg);
+}
+weak_alias(__isinf, isinf);
+
+/**
+ * Test for infinity.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---isinff.html
+ */
+int __isinff(float arg)
+{
+	return isinf(arg);
+}
+weak_alias(__isinff, isinff);
+
+/**
+ * Test for infinity.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---isinfl.html
+ */
+int __isinfl(long double arg)
+{
+	return isinf(arg);
+}
+weak_alias(__isinfl, isinfl);
+
+/**
+ * Test for a NaN.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---isnan.html
+ */
+int __isnan(double arg)
+{
+	return isnan(arg);
+}
+weak_alias(__isnan, isnan);
+
+/**
+ * Test for a NaN.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---isnanf.html
+ */
+int __isnanf(float arg)
+{
+	return isnan(arg);
+}
+weak_alias(__isnanf, isnanf);
+
+/**
+ * Test for a NaN.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---isnanl.html
+ */
+int __isnanl(long double arg)
+{
+	return isnan(arg);
+}
+weak_alias(__isnanl, isnanl);
+
+
+/*
+ * Finite specialisations of functions used by glibc, that aren't supposed to
+ * return infinity.
+ */
+
+#define _ASSERT_FINITE(finite_fn, res)						\
+	GCOMPAT__assert_with_reason(finite_fn(res),			\
+		"infinite value returned in a function that returns a "	\
+		"finite result");
+
+#define ASSERT_FINITEF(res) _ASSERT_FINITE(isinff, res)
+#define ASSERT_FINITE(res) _ASSERT_FINITE(isinf, res)
+#define ASSERT_FINITEL(res) _ASSERT_FINITE(isinfl, res)
+
+/**
+ * Returns the principal value of the arc cosine of x, expressed in radians.
+ */
+float __acosf_finite(float x)
+{
+	float res = acosf(x);
+
+	ASSERT_FINITEF(res);
+
+	return res;
+}
+
+/**
+ * Returns the principal value of the arc cosine of x, expressed in radians.
+ */
+double __acos_finite(double x)
+{
+	double res = acos(x);
+
+	ASSERT_FINITE(res);
+
+	return res;
+}
+
+/**
+ * Returns the principal value of the arc cosine of x, expressed in radians.
+ */
+long double __acosl_finite(long double x)
+{
+	long double res = acosl(x);
+
+	ASSERT_FINITEL(res);
+
+	return res;
+}
+
+/**
+ * Returns the nonnegative area hyperbolic cosine of x.
+ */
+double __acosh_finite(double x)
+{
+	double res = acosh(x);
+
+	ASSERT_FINITE(res);
+
+	return res;
+}
+
+/**
+ * Returns the nonnegative area hyperbolic cosine of x.
+ */
+float __acoshf_finite(float x)
+{
+	float res = acoshf(x);
+
+	ASSERT_FINITEF(res);
+
+	return res;
+}
+
+/**
+ * Returns the nonnegative area hyperbolic cosine of x.
+ */
+long double __acoshl_finite(long double x)
+{
+	long double res = acoshl(x);
+
+	ASSERT_FINITEL(res);
+
+	return res;
+}
+
+/**
+ * Returns the principal value of the arc sine of x, expressed in radians.
+ */
+float __asinf_finite(float x)
+{
+	float res = asinf(x);
+
+	ASSERT_FINITEF(res);
+
+	return res;
+}
+
+/**
+ * Returns the principal value of the arc sine of x, expressed in radians.
+ */
+double __asin_finite(double x)
+{
+	double res = asin(x);
+
+	ASSERT_FINITE(res);
+
+	return res;
+}
+
+/**
+ * Returns the principal value of the arc sine of x, expressed in radians.
+ */
+long double __asinl_finite(long double x)
+{
+	long double res = asinl(x);
+
+	ASSERT_FINITEL(res);
+
+	return res;
+}
+
+/**
+ * Returns the principal value of the arc tangent of x/y, expressed in radians.
+ */
+float __atan2f_finite(float x, float y)
+{
+	float res = atan2f(x, y);
+
+	ASSERT_FINITEF(res);
+
+	return res;
+}
+
+/**
+ * Returns the principal value of the arc tangent of x/y, expressed in radians.
+ */
+double __atan2_finite(double x, double y)
+{
+	double res = atan2(x, y);
+
+	ASSERT_FINITE(res);
+
+	return res;
+}
+
+/**
+ * Returns the principal value of the arc tangent of x/y, expressed in radians.
+ */
+long double __atan2l_finite(long double x, long double y)
+{
+	long double res = atan2l(x, y);
+
+	ASSERT_FINITEL(res);
+
+	return res;
+}
+
+/**
+ * Returns the area hyperbolic tangent of x.
+ */
+float __atanhf_finite(float x)
+{
+	float res = atanhf(x);
+
+	ASSERT_FINITEF(res);
+
+	return res;
+}
+
+/**
+ * Returns the area hyperbolic tangent of x.
+ */
+double __atanh_finite(double x)
+{
+	double res = atanh(x);
+
+	ASSERT_FINITE(res);
+
+	return res;
+}
+
+/**
+ * Returns the area hyperbolic tangent of x.
+ */
+long double __atanhl_finite(long double x)
+{
+	long double res = atanhl(x);
+
+	ASSERT_FINITEL(res);
+
+	return res;
+}
+
+/**
+ * Returns the hyperbolic cosine of x.
+ */
+float __coshf_finite(float x)
+{
+	float res = coshf(x);
+
+	ASSERT_FINITEF(res);
+
+	return res;
+}
+
+/**
+ * Returns the hyperbolic cosine of x.
+ */
+double __cosh_finite(double x)
+{
+	double res = cosh(x);
+
+	ASSERT_FINITE(res);
+
+	return res;
+}
+
+/**
+ * Returns the hyperbolic cosine of x.
+ */
+long double __coshl_finite(long double x)
+{
+	long double res = coshl(x);
+
+	ASSERT_FINITEL(res);
+
+	return res;
+}
+
+/**
+ * Return the value of 10 raised to the power of x.
+ */
+float __exp10f_finite(float x)
+{
+	float res = exp10f(x);
+
+	ASSERT_FINITEF(res);
+
+	return res;
+}
+
+/**
+ * Return the value of 10 raised to the power of x.
+ */
+double __exp10_finite(double x)
+{
+	double res = exp10(x);
+
+	ASSERT_FINITE(res);
+
+	return res;
+}
+
+/**
+ * Return the value of 10 raised to the power of x.
+ */
+long double __exp10l_finite(long double x)
+{
+	long double res = exp10l(x);
+
+	ASSERT_FINITEL(res);
+
+	return res;
+}
+
+/**
+ * Returns the base-2 exponential function of x, which is 2 raised to the power x
+ */
+float __exp2f_finite(float x)
+{
+	float res = exp2f(x);
+
+	ASSERT_FINITEF(res);
+
+	return res;
+}
+
+/**
+ * Returns the base-2 exponential function of x, which is 2 raised to the power x
+ */
+double __exp2_finite(double x)
+{
+	double res = exp2(x);
+
+	ASSERT_FINITE(res);
+
+	return res;
+}
+
+/**
+ * Returns the base-2 exponential function of x, which is 2 raised to the power x
+ */
+long double __exp2l_finite(long double x)
+{
+	long double res = exp2l(x);
+
+	ASSERT_FINITEL(res);
+
+	return res;
+}
+
+/**
+ * Returns the base-e exponential function of x, which is e raised to the power x
+ */
+float __expf_finite(float x)
+{
+	float res = expf(x);
+
+	ASSERT_FINITEF(res);
+
+	return res;
+}
+
+/**
+ * Returns the base-e exponential function of x, which is e raised to the power x
+ */
+double __exp_finite(double x)
+{
+	double res = exp(x);
+
+	ASSERT_FINITE(res);
+
+	return res;
+}
+
+/**
+ * Returns the base-e exponential function of x, which is e raised to the power x
+ */
+long double __expl_finite(long double x)
+{
+	long double res = expl(x);
+
+	ASSERT_FINITEL(res);
+
+	return res;
+}
+
+/**
+ * Returns the floating-point remainder of x/y (rounded towards zero)
+ */
+float __fmodf_finite(float x, float y)
+{
+	float res = fmodf(x, y);
+
+	ASSERT_FINITEF(res);
+
+	return res;
+}
+
+/**
+ * Returns the floating-point remainder of x/y (rounded towards zero)
+ */
+double __fmod_finite(double x, double y)
+{
+	double res = fmod(x, y);
+
+	ASSERT_FINITE(res);
+
+	return res;
+}
+
+/**
+ * Returns the floating-point remainder of x/y (rounded towards zero)
+ */
+long double __fmodl_finite(long double x, long double y)
+{
+	long double res = fmodl(x, y);
+
+	ASSERT_FINITEL(res);
+
+	return res;
+}
+
+/**
+ * Computes the square root of the sum of the squares of x and y, without undue
+ * overflow or underflow at intermediate stages of the computation.
+ */
+float __hypotf_finite(float x, float y)
+{
+	float res = hypotf(x, y);
+
+	ASSERT_FINITEF(res);
+
+	return res;
+}
+
+/**
+ * Computes the square root of the sum of the squares of x and y, without undue
+ * overflow or underflow at intermediate stages of the computation.
+ */
+double __hypot_finite(double x, double y)
+{
+	double res = hypot(x, y);
+
+	ASSERT_FINITE(res);
+
+	return res;
+}
+
+/**
+ * Computes the square root of the sum of the squares of x and y, without undue
+ * overflow or underflow at intermediate stages of the computation.
+ */
+long double __hypotl_finite(long double x, long double y)
+{
+	long double res = hypotl(x, y);
+
+	ASSERT_FINITEL(res);
+
+	return res;
+}
+
+/**
+ * Return Bessel functions of x of the first kind of orders 0.
+ */
+float __j0f_finite(float x)
+{
+	float res = j0f(x);
+
+	ASSERT_FINITEF(res);
+
+	return res;
+}
+
+/**
+ * Return Bessel functions of x of the first kind of orders 0.
+ */
+double __j0_finite(double x)
+{
+	double res = j0(x);
+
+	ASSERT_FINITE(res);
+
+	return res;
+}
+
+/* The below requires support for j0l, see above */
+#if 0
+/**
+ * Return Bessel functions of x of the first kind of orders 0.
+ */
+long double __j0l_finite(long double x)
+{
+	long double res = j0l(x);
+
+	ASSERT_FINITEL(res);
+
+	return res;
+}
+#endif
+
+/**
+ * Return Bessel functions of x of the first kind of orders 1.
+ */
+float __j1f_finite(float x)
+{
+	float res = j1f(x);
+
+	ASSERT_FINITEF(res);
+
+	return res;
+}
+
+/**
+ * Return Bessel functions of x of the first kind of orders 1.
+ */
+double __j1_finite(double x)
+{
+	double res = j1(x);
+
+	ASSERT_FINITE(res);
+
+	return res;
+}
+
+/* The below requires support for j1l, see above */
+#if 0
+/**
+ * Return Bessel functions of x of the first kind of orders 1.
+ */
+long double __j1l_finite(long double x)
+{
+	long double res = j1l(x);
+
+	ASSERT_FINITEL(res);
+
+	return res;
+}
+#endif
+
+/**
+ * Return the Bessel function of x of the first kind of order n.
+ */
+float __jnf_finite(int n, float x)
+{
+	float res = jnf(n, x);
+
+	ASSERT_FINITEF(res);
+
+	return res;
+}
+
+/**
+ * Return the Bessel function of x of the first kind of order n.
+ */
+double __jn_finite(int n, double x)
+{
+	double res = jn(n, x);
+
+	ASSERT_FINITE(res);
+
+	return res;
+}
+
+/* The below requires support for jnl, see above */
+#if 0
+/**
+ * Return the Bessel function of x of the first kind of order n.
+ */
+long double __jnl_finite(int n, long double x)
+{
+	long double res = jnl(n, x);
+
+	ASSERT_FINITEL(res);
+
+	return res;
+}
+#endif
+
+/**
+ * Returns the natural logarithm of the absolute value of the Gamma function.
+ */
+float __lgammaf_finite(float x)
+{
+	float res = lgammaf(x);
+
+	ASSERT_FINITEF(res);
+
+	return res;
+}
+alias(__lgammaf_finite, __gammaf_finite);
+
+/**
+ * Returns the natural logarithm of the absolute value of the Gamma function.
+ */
+double __lgamma_finite(double x)
+{
+	double res = lgamma(x);
+
+	ASSERT_FINITE(res);
+
+	return res;
+}
+alias(__lgamma_finite, __gamma_finite);
+
+/**
+ * Returns the natural logarithm of the absolute value of the Gamma function.
+ */
+long double __lgammal_finite(long double x)
+{
+	long double res = lgammal(x);
+
+	ASSERT_FINITEL(res);
+
+	return res;
+}
+alias(__lgammal_finite, __gammal_finite);
+
+/**
+ * Returns the natural logarithm of the absolute value of the Gamma function.
+ */
+float __lgammaf_r_finite(float x, int *p)
+{
+	float res = lgammaf_r(x, p);
+
+	ASSERT_FINITEF(res);
+
+	return res;
+}
+alias(__lgammaf_r_finite, __gammaf_r_finite);
+
+/**
+ * Returns the natural logarithm of the absolute value of the Gamma function.
+ */
+double __lgamma_r_finite(double x, int *p)
+{
+	double res = lgamma_r(x, p);
+
+	ASSERT_FINITE(res);
+
+	return res;
+}
+alias(__lgamma_r_finite, __gamma_r_finite);
+
+/**
+ * Returns the natural logarithm of the absolute value of the Gamma function.
+ */
+long double __lgammal_r_finite(long double x, int *p)
+{
+	long double res = lgammal_r(x, p);
+
+	ASSERT_FINITEL(res);
+
+	return res;
+}
+alias(__lgammal_r_finite, __gammal_r_finite);
+
+/**
+ * Returns the common (base-10) logarithm of x.
+ */
+float __log10f_finite(float x)
+{
+	float res = log10f(x);
+
+	ASSERT_FINITEF(res);
+
+	return res;
+}
+
+/**
+ * Returns the common (base-10) logarithm of x.
+ */
+double __log10_finite(double x)
+{
+	double res = log10(x);
+
+	ASSERT_FINITE(res);
+
+	return res;
+}
+
+/**
+ * Returns the common (base-10) logarithm of x.
+ */
+long double __log10l_finite(long double x)
+{
+	long double res = log10l(x);
+
+	ASSERT_FINITEL(res);
+
+	return res;
+}
+
+/**
+ * Returns the binary (base-2) logarithm of x.
+ */
+float __log2f_finite(float x)
+{
+	float res = log2f(x);
+
+	ASSERT_FINITEF(res);
+
+	return res;
+}
+
+/**
+ * Returns the binary (base-2) logarithm of x.
+ */
+double __log2_finite(double x)
+{
+	double res = log2(x);
+
+	ASSERT_FINITE(res);
+
+	return res;
+}
+
+/**
+ * Returns the binary (base-2) logarithm of x.
+ */
+long double __log2l_finite(long double x)
+{
+	long double res = log2l(x);
+
+	ASSERT_FINITEL(res);
+
+	return res;
+}
+
+/**
+ * Returns the natural logarithm of x.
+ */
+float __logf_finite(float x)
+{
+	float res = logf(x);
+
+	ASSERT_FINITEF(res);
+
+	return res;
+}
+
+/**
+ * Returns the natural logarithm of x.
+ */
+double __log_finite(double x)
+{
+	double res = log(x);
+
+	ASSERT_FINITE(res);
+
+	return res;
+}
+
+/**
+ * Returns the natural logarithm of x.
+ */
+long double __logl_finite(long double x)
+{
+	long double res = logl(x);
+
+	ASSERT_FINITEL(res);
+
+	return res;
+}
+
+/**
+ * Returns x raised to the y exponent.
+ */
+float __powf_finite(float x, float y)
+{
+	float res = powf(x, y);
+
+	ASSERT_FINITEF(res);
+
+	return res;
+}
+
+/**
+ * Returns x raised to the y exponent.
+ */
+double __pow_finite(double x, double y)
+{
+	double res = pow(x, y);
+
+	ASSERT_FINITE(res);
+
+	return res;
+}
+
+/**
+ * Returns x raised to the y exponent.
+ */
+long double __powl_finite(long double x, long double y)
+{
+	long double res = powl(x, y);
+
+	ASSERT_FINITEL(res);
+
+	return res;
+}
+
+/**
+ * Returns the floating-point remainder of x/y (rounded to nearest).
+ */
+float __remainderf_finite(float x, float y)
+{
+	float res = remainderf(x, y);
+
+	ASSERT_FINITEF(res);
+
+	return res;
+}
+
+/**
+ * Returns the floating-point remainder of x/y (rounded to nearest).
+ */
+double __remainder_finite(double x, double y)
+{
+	double res = remainder(x, y);
+
+	ASSERT_FINITE(res);
+
+	return res;
+}
+
+/**
+ * Returns the floating-point remainder of x/y (rounded to nearest).
+ */
+long double __remainderl_finite(long double x, long double y)
+{
+	long double res = remainderl(x, y);
+
+	ASSERT_FINITEL(res);
+
+	return res;
+}
+
+/**
+ * Multiplies the first argument x by FLT_RADIX (probably 2) to the power of y.
+ */
+float __scalbf_finite(float x, float y)
+{
+	float res = scalbf(x, y);
+
+	ASSERT_FINITEF(res);
+
+	return res;
+}
+
+/**
+ * Multiplies the first argument x by FLT_RADIX (probably 2) to the power of y.
+ */
+double __scalb_finite(double x, double y)
+{
+	double res = scalb(x, y);
+
+	ASSERT_FINITE(res);
+
+	return res;
+}
+
+/**
+ * Multiplies the first argument x by FLT_RADIX (probably 2) to the power of y.
+ */
+long double __scalbl_finite(long double x, long double y)
+{
+	long double res = scalbl(x, y);
+
+	ASSERT_FINITEL(res);
+
+	return res;
+}
+
+/**
+ * Returns the hyperbolic sine of x.
+ */
+float __sinhf_finite(float x)
+{
+	float res = sinhf(x);
+
+	ASSERT_FINITEF(res);
+
+	return res;
+}
+
+/**
+ * Returns the hyperbolic sine of x.
+ */
+double __sinh_finite(double x)
+{
+	double res = sinh(x);
+
+	ASSERT_FINITE(res);
+
+	return res;
+}
+
+/**
+ * Returns the hyperbolic sine of x.
+ */
+long double __sinhl_finite(long double x)
+{
+	long double res = sinhl(x);
+
+	ASSERT_FINITEL(res);
+
+	return res;
+}
+
+/**
+ * Returns the square root of x.
+ */
+float __sqrtf_finite(float x)
+{
+	float res = sqrtf(x);
+
+	ASSERT_FINITEF(res);
+
+	return res;
+}
+
+/**
+ * Returns the square root of x.
+ */
+double __sqrt_finite(double x)
+{
+	double res = sqrt(x);
+
+	ASSERT_FINITE(res);
+
+	return res;
+}
+
+/**
+ * Returns the square root of x.
+ */
+long double __sqrtl_finite(long double x)
+{
+	long double res = sqrtl(x);
+
+	ASSERT_FINITEL(res);
+
+	return res;
+}
+
+/**
+ * Return Bessel functions of x of the second kind of order 0.
+ */
+float __y0f_finite(float x)
+{
+	float res = y0f(x);
+
+	ASSERT_FINITEF(res);
+
+	return res;
+}
+
+/**
+ * Return Bessel functions of x of the second kind of order 0.
+ */
+double __y0_finite(double x)
+{
+	double res = y0(x);
+
+	ASSERT_FINITE(res);
+
+	return res;
+}
+
+/* The below requires support for y0l, see above */
+#if 0
+/**
+ * Return Bessel functions of x of the second kind of order 0.
+ */
+long double __y0l_finite(long double x)
+{
+	long double res = y0l(x);
+
+	ASSERT_FINITEL(res);
+
+	return res;
+}
+#endif
+
+/**
+ * Return Bessel functions of x of the second kind of order 1.
+ */
+float __y1f_finite(float x)
+{
+	float res = y1f(x);
+
+	ASSERT_FINITEF(res);
+
+	return res;
+}
+
+/**
+ * Return Bessel functions of x of the second kind of order 1.
+ */
+double __y1_finite(double x)
+{
+	double res = y1(x);
+
+	ASSERT_FINITE(res);
+
+	return res;
+}
+
+/* The below requires support for y1l, see above */
+#if 0
+/**
+ * Return Bessel functions of x of the second kind of order 1.
+ */
+long double __y1l_finite(long double x)
+{
+	long double res = y1l(x);
+
+	ASSERT_FINITEL(res);
+
+	return res;
+}
+#endif
+
+/**
+ * Return Bessel functions of x of the second kind of order n.
+ */
+float __ynf_finite(int n, float x)
+{
+	float res = ynf(n, x);
+
+	ASSERT_FINITEF(res);
+
+	return res;
+}
+
+/**
+ * Return Bessel functions of x of the second kind of order n.
+ */
+double __yn_finite(int n, double x)
+{
+	double res = yn(n, x);
+
+	ASSERT_FINITE(res);
+
+	return res;
+}
+
+/* The below requires support for ynl, see above */
+#if 0
+/**
+ * Return Bessel functions of x of the second kind of order n.
+ */
+long double __ynl_finite(int n, long double x)
+{
+	long double res = ynl(n, x);
+
+	ASSERT_FINITEL(res);
+
+	return res;
+}
+#endif
diff --git a/src/libgcompat/misc.c b/src/libgcompat/misc.c
new file mode 100644
index 0000000..0677550
--- /dev/null
+++ b/src/libgcompat/misc.c
@@ -0,0 +1,35 @@
+#include <stdlib.h>        /* abort, at_quick_exit */
+#include <sys/stat.h>      /* dev_t */
+#include <sys/sysmacros.h> /* major, makedev, minor */
+
+/**
+ * Terminate a function in case of buffer overflow.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---chk-fail-1.html
+ */
+void __chk_fail(void)
+{
+	abort();
+}
+
+int __cxa_at_quick_exit(void (*func)(void), void *__dso_handle)
+{
+	return at_quick_exit(func);
+}
+
+unsigned int gnu_dev_major(dev_t dev)
+{
+	return major(dev);
+}
+
+dev_t gnu_dev_makedev(unsigned int maj, unsigned int min)
+{
+	return makedev(maj, min);
+}
+
+unsigned int gnu_dev_minor(dev_t dev)
+{
+	return minor(dev);
+}
+
+void *__libc_stack_end = NULL;
diff --git a/src/libgcompat/netdb.c b/src/libgcompat/netdb.c
new file mode 100644
index 0000000..ae7713a
--- /dev/null
+++ b/src/libgcompat/netdb.c
@@ -0,0 +1,79 @@
+#include <errno.h>  /* ENOENT */
+#include <netdb.h>  /* getproto* */
+#include <stddef.h> /* NULL, size_t */
+#include <string.h> /* memcpy */
+
+/**
+ * Retrieve information from the network protocol database by protocol name,
+ * reentrantly.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib-getprotobyname-r.html
+ */
+int getprotobyname_r(const char *name, struct protoent *result_buf, char *buf,
+                     size_t buflen, struct protoent **result)
+{
+	struct protoent *prototmp = getprotobyname(name);
+
+	/* musl does not reuse static storage, so no race is possible. */
+	if (prototmp == NULL) {
+		*result = NULL;
+		return ENOENT;
+	}
+	*result = memcpy(result_buf, prototmp, sizeof(*result_buf));
+
+	return 0;
+}
+
+/**
+ * Retrieve information from the network protocol database by protocol number,
+ * reentrantly.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib-getprotobynumber-r.html
+ */
+int getprotobynumber_r(int proto, struct protoent *result_buf, char *buf,
+                       size_t buflen, struct protoent **result)
+{
+	struct protoent *prototmp = getprotobynumber(proto);
+
+	/* musl does not reuse static storage, so no race is possible. */
+	if (prototmp == NULL) {
+		*result = NULL;
+		return ENOENT;
+	}
+	*result = memcpy(result_buf, prototmp, sizeof(*result_buf));
+
+	return 0;
+}
+
+/**
+ * Read the next entry of the protocol database, reentrantly.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib-getprotoent-r.html
+ */
+int getprotoent_r(struct protoent *result_buf, char *buf, size_t buflen,
+                  struct protoent **result)
+{
+	struct protoent *prototmp = getprotoent();
+
+	/* musl does not reuse static storage, so no race is possible. */
+	if (prototmp == NULL) {
+		*result = NULL;
+		return ENOENT;
+	}
+	*result = memcpy(result_buf, prototmp, sizeof(*result_buf));
+
+	return 0;
+}
+
+/**
+ * Read the next entry of the network services database, reentrantly.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib-getservent-r.html
+ */
+int getservent_r(struct servent *result_buf, char *buf, size_t buflen,
+                 struct servent **result)
+{
+	/* musl does not implement getservent(). */
+	*result = NULL;
+	return ENOENT;
+}
diff --git a/src/libgcompat/pthread.c b/src/libgcompat/pthread.c
new file mode 100644
index 0000000..f15e9f1
--- /dev/null
+++ b/src/libgcompat/pthread.c
@@ -0,0 +1,54 @@
+#define _GNU_SOURCE
+#include <errno.h>   /* errno */
+#include <fcntl.h>   /* O_CLOEXEC, O_RDONLY */
+#include <pthread.h> /* pthread_atfork */
+#include <unistd.h>  /* open, read */
+
+#include "alias.h" /* weak_alias */
+
+/**
+ * Underlying function for pthread_cleanup_push.
+ */
+void __pthread_register_cancel(void *buf)
+{
+}
+
+/**
+ * Underlying function for pthread_cleanup_push.
+ */
+void __pthread_unregister_cancel(void *buf)
+{
+}
+
+/**
+ * Register fork handlers.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---register-atfork.html
+ */
+int __register_atfork(void (*prepare)(void), void (*parent)(void),
+                      void (*child)(void), void *__dso_handle)
+{
+	return pthread_atfork(prepare, parent, child);
+}
+weak_alias(__register_atfork, register_atfork);
+
+/**
+ * Get the name of a thread.
+ */
+int pthread_getname_np(pthread_t thread, char *name, size_t len)
+{
+	int fd = open("/proc/thread-self/comm", O_RDONLY | O_CLOEXEC);
+	ssize_t n;
+
+	if (fd < 0)
+		return errno;
+	n = read(fd, name, len);
+	if (n < 0)
+		return errno;
+	/* If the trailing newline was not read, the buffer was too small. */
+	if (n == 0 || name[n - 1] != '\n')
+		return ERANGE;
+	name[n - 1] = '\0';
+
+	return 0;
+}
diff --git a/src/libgcompat/pwd.c b/src/libgcompat/pwd.c
new file mode 100644
index 0000000..34c5d7b
--- /dev/null
+++ b/src/libgcompat/pwd.c
@@ -0,0 +1,92 @@
+/* some musl versions incorrectly mark fgetpwent() as a GNU extension */
+#define _GNU_SOURCE
+#include <assert.h>  /* assert */
+#include <errno.h>   /* ENOENT, ERANGE */
+#include <pthread.h> /* pthread_mutex_* */
+#include <pwd.h>     /* fgetpwent, getpwent, struct passwd */
+#include <stddef.h>  /* NULL, size_t */
+#include <stdio.h>   /* FILE */
+#include <string.h>  /* memcpy, stpcpy, strlcpy, strlen */
+
+static pthread_mutex_t pwent_mutex = PTHREAD_MUTEX_INITIALIZER;
+
+static int __fgetpwent_r(FILE *stream, struct passwd *pwd, char *buf,
+                         size_t len, struct passwd **result)
+{
+	struct passwd *pwtmp;
+	char *cursor = buf, *end = buf + len;
+
+	*result = NULL;
+	pthread_mutex_lock(&pwent_mutex);
+	pwtmp = stream != NULL ? fgetpwent(stream) : getpwent();
+	if (pwtmp == NULL) {
+		pthread_mutex_unlock(&pwent_mutex);
+		return ENOENT;
+	}
+	memcpy(pwd, pwtmp, sizeof(*pwd));
+	if (pwtmp->pw_name != NULL) {
+		pwd->pw_name = cursor;
+		cursor += strlcpy(cursor, pwtmp->pw_name, end - cursor) + 1;
+		if (cursor > end) {
+			goto err_unlock;
+		}
+	}
+	if (pwtmp->pw_passwd != NULL) {
+		pwd->pw_passwd = cursor;
+		cursor += strlcpy(cursor, pwtmp->pw_passwd, end - cursor) + 1;
+		if (cursor > end) {
+			goto err_unlock;
+		}
+	}
+	if (pwtmp->pw_gecos != NULL) {
+		pwd->pw_gecos = cursor;
+		cursor += strlcpy(cursor, pwtmp->pw_gecos, end - cursor) + 1;
+		if (cursor > end) {
+			goto err_unlock;
+		}
+	}
+	if (pwtmp->pw_dir != NULL) {
+		pwd->pw_dir = cursor;
+		cursor += strlcpy(cursor, pwtmp->pw_dir, end - cursor) + 1;
+		if (cursor > end) {
+			goto err_unlock;
+		}
+	}
+	if (pwtmp->pw_shell != NULL) {
+		pwd->pw_shell = cursor;
+		cursor += strlcpy(cursor, pwtmp->pw_shell, end - cursor) + 1;
+		if (cursor > end) {
+			goto err_unlock;
+		}
+	}
+	pthread_mutex_unlock(&pwent_mutex);
+	*result = pwd;
+
+	return 0;
+
+err_unlock:
+	pthread_mutex_unlock(&pwent_mutex);
+	return ERANGE;
+}
+
+/**
+ * Get passwd file entry.
+ */
+int fgetpwent_r(FILE *stream, struct passwd *pwd, char *buf, size_t len,
+                struct passwd **result)
+{
+	assert(stream != NULL);
+
+	return fgetpwent_r(stream, pwd, buf, len, result);
+}
+
+/**
+ * Get user database entry.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib-getpwent-r-1.html
+ */
+int getpwent_r(struct passwd *pwd, char *buf, size_t len,
+               struct passwd **result)
+{
+	return __fgetpwent_r(NULL, pwd, buf, len, result);
+}
diff --git a/src/libgcompat/resolv.c b/src/libgcompat/resolv.c
new file mode 100644
index 0000000..0b81d0c
--- /dev/null
+++ b/src/libgcompat/resolv.c
@@ -0,0 +1,48 @@
+/*
+ * Original author: Khem Raj <raj.khem@gmail.com>
+ *
+ * Mimick GLIBC's res_ninit() and res_nclose() for musl libc
+ * Note: res_init() is actually deprecated according to
+ * http://docs.oracle.com/cd/E36784_01/html/E36875/res-nclose-3resolv.html
+ */
+
+#include <resolv.h> /* res_state */
+#include <stddef.h> /* NULL */
+#include <string.h> /* memcpy, memset */
+
+#include "alias.h" /* weak_alias */
+
+int __res_ninit(res_state statp)
+{
+	int rc;
+
+	if (statp == NULL) {
+		return -1;
+	}
+	rc = res_init();
+	if (statp != &_res) {
+		memcpy(statp, &_res, sizeof(*statp));
+	}
+
+	return rc;
+}
+weak_alias(__res_ninit, res_ninit);
+
+int __res_nclose(res_state statp)
+{
+	if (statp == NULL) {
+		return -1;
+	}
+	if (statp != &_res) {
+		memset(statp, 0, sizeof(*statp));
+	}
+
+	return 0;
+}
+weak_alias(__res_nclose, res_nclose);
+
+int __res_search(const char *dname, int class, int type, unsigned char *answer,
+                 int anslen)
+{
+	return res_search(dname, class, type, answer, anslen);
+}
diff --git a/src/libgcompat/setjmp.c b/src/libgcompat/setjmp.c
new file mode 100644
index 0000000..306868f
--- /dev/null
+++ b/src/libgcompat/setjmp.c
@@ -0,0 +1,7 @@
+#include <assert.h>
+#include <setjmp.h>
+
+void __longjmp_chk(jmp_buf env, int val)
+{
+	longjmp(env, val);
+}
diff --git a/src/libgcompat/signal.c b/src/libgcompat/signal.c
new file mode 100644
index 0000000..17e5443
--- /dev/null
+++ b/src/libgcompat/signal.c
@@ -0,0 +1,11 @@
+#include <signal.h> /* sigpause */
+
+/**
+ * Remove a signal from the signal mask and suspend the thread.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---xpg-sigpause.html
+ */
+int __xpg_sigpause(int sig)
+{
+	return sigpause(sig);
+}
diff --git a/src/libgcompat/socket.c b/src/libgcompat/socket.c
new file mode 100644
index 0000000..e56199e
--- /dev/null
+++ b/src/libgcompat/socket.c
@@ -0,0 +1,55 @@
+#include <assert.h>     /* assert */
+#include <poll.h>       /* poll, pollfd, nfds_t */
+#include <stddef.h>     /* NULL */
+#include <sys/socket.h> /* recv, recvfrom */
+
+/**
+ * Found in the wild needed by libcef.  It looks like glibc moved to a
+ * pure preprocessor-based solution some time ago, but this remains for
+ * compatibility.
+ */
+struct cmsghdr *__cmsg_nxthdr(struct msghdr *msg, struct cmsghdr *cmsg)
+{
+	return CMSG_NXTHDR(msg, cmsg);
+}
+
+/**
+ * Receive a message from a connected socket, with buffer overflow checking.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---recv-chk-1.html
+ */
+ssize_t __recv_chk(int fd, void *buf, size_t len, size_t buflen, int flags)
+{
+	assert(buf != NULL);
+	assert(buflen >= len);
+
+	return recv(fd, buf, len, flags);
+}
+
+/**
+ * Receive a message from a socket, with buffer overflow checking.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---recvfrom-chk-1.html
+ */
+ssize_t __recvfrom_chk(int fd, void *buf, size_t len, size_t buflen, int flags,
+                       struct sockaddr *address, socklen_t *address_len)
+{
+	assert(buf != NULL);
+	assert(buflen >= len);
+	assert(address != NULL ? address_len != NULL : address_len == NULL);
+
+	return recvfrom(fd, buf, len, flags, address, address_len);
+}
+
+/**
+ * Checked version of poll, not in LSB but found in the wild.
+ *
+ * This checks if the size of fds is large enough to hold all the fd's claimed
+ * in nfds.
+ */
+int __poll_chk(struct pollfd *fds, nfds_t nfds, int timeout, size_t fdslen)
+{
+	assert((fdslen / sizeof(*fds)) < nfds);
+
+	return poll(fds, nfds, timeout);
+}
diff --git a/src/libgcompat/stdio.c b/src/libgcompat/stdio.c
new file mode 100644
index 0000000..0ff5feb
--- /dev/null
+++ b/src/libgcompat/stdio.c
@@ -0,0 +1,236 @@
+#define _GNU_SOURCE /* fgets_unlocked */
+#include <assert.h> /* assert */
+#include <stdarg.h> /* va_list, va_start, va_end */
+#include <stddef.h> /* NULL, size_t */
+#include <stdio.h>  /* feof, fgets, fread, puts, v*printf */
+
+int __vasprintf_chk(char **strp, int flag, const char *format, va_list ap);
+int __vfprintf_chk(FILE *stream, int flag, const char *format, va_list ap);
+int __vsnprintf_chk(char *s, size_t n, int flag, size_t slen,
+                    const char *format, va_list ap);
+int __vsprintf_chk(char *s, int flag, size_t slen, const char *format,
+                   va_list ap);
+
+/**
+ * Test end-of-file indicator on a stream.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib--io-feof-3.html
+ */
+int _IO_feof(FILE *stream)
+{
+	return feof(stream);
+}
+
+/**
+ * Put a string on standard output.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib--io-puts-3.html
+ */
+int _IO_puts(const char *c)
+{
+	return puts(c);
+}
+
+/**
+ * Print to allocated string, with stack checking.
+ */
+int __asprintf_chk(char **strp, int flag, const char *format, ...)
+{
+	int ret;
+	va_list ap;
+
+	va_start(ap, format);
+	ret = __vasprintf_chk(strp, flag, format, ap);
+	va_end(ap);
+
+	return ret;
+}
+
+/**
+ * String input, with buffer overflow checking.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---fgets-chk-1.html
+ */
+char *__fgets_chk(char *s, size_t slen, int n, FILE *stream)
+{
+	assert(s != NULL);
+	assert(slen >= (size_t) n);
+	assert(n > 0);
+	assert(stream != NULL);
+
+	return fgets(s, n, stream);
+}
+
+/**
+ * Non-locking string input, with buffer overflow checking.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---fgets-unlocked-chk-1.html
+ */
+char *__fgets_unlocked_chk(char *s, size_t slen, int n, FILE *stream)
+{
+	assert(s != NULL);
+	assert(slen >= (size_t) n);
+	assert(n > 0);
+	assert(stream != NULL);
+
+	return fgets_unlocked(s, n, stream);
+}
+
+/**
+ * Convert formatted output, with stack checking.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---fprintf-chk-1.html
+ */
+int __fprintf_chk(FILE *stream, int flag, const char *format, ...)
+{
+	int ret;
+	va_list ap;
+
+	va_start(ap, format);
+	ret = __vfprintf_chk(stream, flag, format, ap);
+	va_end(ap);
+
+	return ret;
+}
+
+/**
+ * Binary input, with stack checking.
+ */
+size_t __fread_chk(void *buf, size_t buflen, size_t size, size_t nitems,
+                   FILE *stream)
+{
+	assert(buf != NULL);
+	assert(size > 0);
+	assert(buflen / size >= nitems);
+	assert(stream != NULL);
+
+	return fread(buf, size, nitems, stream);
+}
+
+/**
+ * Format and print data, with stack checking.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---printf-chk-1.html
+ */
+int __printf_chk(int flag, const char *format, ...)
+{
+	int ret;
+	va_list ap;
+
+	va_start(ap, format);
+	ret = __vfprintf_chk(stdout, flag, format, ap);
+	va_end(ap);
+
+	return ret;
+}
+
+/**
+ * Convert formatted output, with buffer overflow checking.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---snprintf-chk-1.html
+ */
+int __snprintf_chk(char *s, size_t n, int flag, size_t slen, const char *format,
+                   ...)
+{
+	int ret;
+	va_list ap;
+
+	va_start(ap, format);
+	ret = __vsnprintf_chk(s, n, flag, slen, format, ap);
+	va_end(ap);
+
+	return ret;
+}
+
+/**
+ * Convert formatted output, with stack checking.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---sprintf-chk-1.html
+ */
+int __sprintf_chk(char *s, int flag, size_t slen, const char *format, ...)
+{
+	int ret;
+	va_list ap;
+
+	va_start(ap, format);
+	ret = __vsprintf_chk(s, flag, slen, format, ap);
+	va_end(ap);
+
+	return ret;
+}
+
+/**
+ * Print to allocated string, with stack checking.
+ */
+int __vasprintf_chk(char **strp, int flag, const char *format, va_list ap)
+{
+	assert(strp != NULL);
+	assert(format != NULL);
+
+	return vasprintf(strp, format, ap);
+}
+
+/**
+ * Convert formatted output, with stack checking.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---vfprintf-chk-1.html
+ */
+int __vfprintf_chk(FILE *stream, int flag, const char *format, va_list ap)
+{
+	assert(stream != NULL);
+	assert(format != NULL);
+
+	return vfprintf(stream, format, ap);
+}
+
+/**
+ * Convert formatted output, with stack checking.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---vprintf-chk-1.html
+ */
+int __vprintf_chk(int flag, const char *format, va_list ap)
+{
+	return __vfprintf_chk(stdout, flag, format, ap);
+}
+
+/**
+ * Convert formatted output, with stack checking.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---vsnprintf-chk-1.html
+ */
+int __vsnprintf_chk(char *s, size_t n, int flag, size_t slen,
+                    const char *format, va_list ap)
+{
+	assert(s != NULL || n == 0);
+	assert(slen >= n);
+	assert(format != NULL);
+
+	return vsnprintf(s, n, format, ap);
+}
+
+/**
+ * Convert formatted output, with stack checking.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---vsprintf-chk-1.html
+ */
+int __vsprintf_chk(char *s, int flag, size_t slen, const char *format,
+                   va_list ap)
+{
+	assert(s != NULL);
+	assert(slen > 0);
+	assert(format != NULL);
+
+	return vsprintf(s, format, ap);
+}
+
+/**
+ * Create a name for a temporary file.
+ */
+char *tmpnam_r(char *s)
+{
+	if (s == NULL) {
+		return NULL;
+	}
+
+	return tmpnam(s);
+}
diff --git a/src/libgcompat/stdlib.c b/src/libgcompat/stdlib.c
new file mode 100644
index 0000000..82f7602
--- /dev/null
+++ b/src/libgcompat/stdlib.c
@@ -0,0 +1,129 @@
+#include <assert.h> /* assert */
+#include <limits.h> /* PATH_MAX */
+#include <locale.h> /* locale_t */
+#include <stddef.h> /* NULL, size_t */
+#include <stdlib.h> /* getenv, realpath, strto* */
+#include <unistd.h> /* get*id */
+
+#include "alias.h"
+
+/**
+ * Resolve a pathname, with buffer overflow checking.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---realpath-chk-1.html
+ */
+char *__realpath_chk(const char *path, char *resolved_path, size_t resolved_len)
+{
+	assert(path != NULL);
+	assert(resolved_path != NULL);
+	assert(resolved_len >= PATH_MAX);
+
+	return realpath(path, resolved_path);
+}
+
+/**
+ * Get an environment variable.
+ */
+char *__secure_getenv(const char *name)
+{
+	if (geteuid() != getuid() || getegid() != getgid()) {
+		return NULL;
+	}
+
+	return getenv(name);
+}
+weak_alias(__secure_getenv, secure_getenv);
+
+/**
+ * Underlying function for strtod.
+ *
+ * "__group shall be 0 or the behavior of __strtod_internal() is undefined."
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---strtod-internal-1.html
+ */
+double __strtod_internal(const char *nptr, char **endptr, int group)
+{
+	assert(group == 0);
+
+	return strtod(nptr, endptr);
+}
+
+/**
+ * Underlying function for strtof.
+ *
+ * "__group shall be 0 or the behavior of __strtof_internal() is undefined."
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---strtof-internal.html
+ */
+float __strtof_internal(const char *nptr, char **endptr, int group)
+{
+	assert(group == 0);
+
+	return strtof(nptr, endptr);
+}
+
+/**
+ * Underlying function for strtol.
+ */
+long __strtol_internal(const char *nptr, char **endptr, int base, int group)
+{
+	assert(group == 0);
+
+	return strtol(nptr, endptr, base);
+}
+
+/**
+ * Underlying function for strtold.
+ *
+ * "__group shall be 0 or the behavior of __strtold_internal() is undefined."
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---strtold-internal-1.html
+ */
+long double __strtold_internal(const char *nptr, char **endptr, int group)
+{
+	assert(group == 0);
+
+	return strtold(nptr, endptr);
+}
+
+/**
+ * Convert string value to a long long integer.
+ *
+ * Some day, when musl supports LC_NUMERIC, we can probably remove this.
+ */
+long long int strtoll_l(const char *nptr, char **endptr, int base,
+                        locale_t locale)
+{
+	return strtoll(nptr, endptr, base);
+}
+
+/**
+ * Convert string value to a long long integer.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib-strtoq-3.html
+ */
+long long strtoq(const char *nptr, char **endptr, int base)
+{
+	return strtoll(nptr, endptr, base);
+}
+
+/**
+ * Convert a string to an unsigned long long.
+ *
+ * Some day, when musl supports LC_NUMERIC, we can probably remove this.
+ */
+unsigned long long int strtoull_l(const char *nptr, char **endptr, int base,
+                                  locale_t locale)
+{
+	return strtoull(nptr, endptr, base);
+}
+
+/**
+ * Convert a string to an unsigned long long.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib-strtouq-3.html
+ */
+unsigned long long strtouq(const char *nptr, char **endptr, int base)
+{
+	return strtoull(nptr, endptr, base);
+}
diff --git a/src/libgcompat/string.c b/src/libgcompat/string.c
new file mode 100644
index 0000000..9852bea
--- /dev/null
+++ b/src/libgcompat/string.c
@@ -0,0 +1,311 @@
+#define _GNU_SOURCE /* mempcpy */
+#include <assert.h> /* assert */
+#include <stddef.h> /* NULL, size_t */
+#include <stdint.h> /* SIZE_MAX */
+#include <stdlib.h> /* rand_r */
+#include <string.h> /* memcpy, strcpy, strncat, strndup */
+#include <time.h>   /* time */
+#include <unistd.h> /* getpid */
+
+#include "alias.h" /* weak_alias */
+
+/**
+ * Copy bytes in memory, with buffer overflow checking.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---memcpy-chk-1.html
+ */
+void *__memcpy_chk(void *dest, const void *src, size_t n, size_t destlen)
+{
+	assert(dest != NULL);
+	assert(src != NULL);
+	assert(destlen >= n);
+	if (dest < src) {
+		assert((char *) dest + n <= (char *) src);
+	} else {
+		assert((char *) src + n <= (char *) dest);
+	}
+
+	return memcpy(dest, src, n);
+}
+
+/**
+ * Copy bytes in memory with overlapping areas, with buffer overflow checking.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---memmove-chk-1.html
+ */
+void *__memmove_chk(void *dest, const void *src, size_t n, size_t destlen)
+{
+	assert(dest != NULL);
+	assert(src != NULL);
+	assert(destlen >= n);
+
+	return memmove(dest, src, n);
+}
+
+/**
+ * Copy bytes in memory.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---mempcpy.html
+ */
+void *__mempcpy(void *dest, const void *src, size_t n)
+{
+	return mempcpy(dest, src, n);
+}
+
+/**
+ * Copy bytes in memory, with buffer overflow checking.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---mempcpy-chk-1.html
+ */
+void *__mempcpy_chk(void *dest, const void *src, size_t n, size_t destlen)
+{
+	assert(dest != NULL);
+	assert(src != NULL);
+	assert(destlen >= n);
+	if (dest < src) {
+		assert((char *) dest + n <= (char *) src);
+	} else {
+		assert((char *) src + n <= (char *) dest);
+	}
+
+	return mempcpy(dest, src, n);
+}
+
+/**
+ * Set bytes in memory, with buffer overflow checking.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---memset-chk-1.html
+ */
+void *__memset_chk(void *s, int c, size_t n, size_t buflen)
+{
+	assert(s != NULL);
+	assert(buflen >= n);
+
+	return memset(s, c, n);
+}
+
+/**
+ * Find byte in memory.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---rawmemchr.html
+ */
+void *__rawmemchr(const void *s, int c)
+{
+	return memchr(s, c, SIZE_MAX);
+}
+weak_alias(__rawmemchr, rawmemchr);
+
+/**
+ * Copy a string and return a pointer to the end of the result, with buffer
+ * overflow checking.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---stpcpy-chk-1.html
+ */
+char *__stpcpy_chk(char *dest, const char *src, size_t destlen)
+{
+	size_t n;
+
+	assert(dest != NULL);
+	assert(src != NULL);
+	n = strlen(src) + 1;
+	assert(destlen >= n);
+	if (dest < src) {
+		assert(dest + n <= src);
+	} else {
+		assert(src + n <= dest);
+	}
+
+	return stpcpy(dest, src);
+}
+
+/**
+ * Copy a fixed-length string, returning a pointer to the array end, with buffer
+ * overflow checking.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---stpncpy-chk-1.html
+ */
+char *__stpncpy_chk(char *dest, const char *src, size_t n, size_t destlen)
+{
+	assert(dest != NULL);
+	assert(src != NULL);
+	assert(destlen >= n);
+	if (dest < src) {
+		assert(dest + n <= src);
+	} else {
+		assert(src + n <= dest);
+	}
+
+	return stpncpy(dest, src, n);
+}
+
+/**
+ * Concatenate two strings, with buffer overflow checking.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---strcat-chk-1.html
+ */
+char *__strcat_chk(char *dest, const char *src, size_t destlen)
+{
+	size_t n;
+	size_t total;
+
+	assert(dest != NULL);
+	assert(src != NULL);
+	n = strlen(src) + 1;
+	total = strnlen(dest, destlen) + n;
+	assert(destlen >= total);
+	if (dest < src) {
+		assert(dest + total <= src);
+	} else {
+		assert(src + n <= dest);
+	}
+
+	return strcat(dest, src);
+}
+
+/**
+ * Copy a string, with buffer overflow checking.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---strcpy-chk-1.html
+ */
+char *__strcpy_chk(char *dest, const char *src, size_t destlen)
+{
+	size_t n;
+
+	assert(dest != NULL);
+	assert(src != NULL);
+	n = strlen(src) + 1;
+	assert(destlen >= n);
+	if (dest < src) {
+		assert(dest + n <= src);
+	} else {
+		assert(src + n <= dest);
+	}
+
+	return strcpy(dest, src);
+}
+
+/**
+ * Find the substring length of a string that does not have any two characters.
+ *
+ * Not defined in LSB 5.0.  Used by spotify-client.
+ */
+size_t __strcspn_c2(const char *str, int bad, int bad2)
+{
+	size_t length = 0;
+	const char *s = str;
+	while (*s != bad && *s != bad2 && *s != '\0') {
+		length++;
+		s++;
+	}
+	return length;
+}
+
+/**
+ * Alias for strdup.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---strdup-1.html
+ */
+char *__strdup(const char *string)
+{
+	return strdup(string);
+}
+
+/**
+ * Concatenate a string with part of another, with buffer overflow checking.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---strncat-chk-1.html
+ */
+char *__strncat_chk(char *dest, const char *src, size_t n, size_t destlen)
+{
+	size_t total;
+
+	assert(dest != NULL);
+	assert(src != NULL);
+	total = strnlen(dest, destlen) + n + 1;
+	assert(destlen >= total);
+	if (dest < src) {
+		assert(dest + total <= src);
+	} else {
+		assert(src + n <= dest);
+	}
+
+	return strncat(dest, src, n);
+}
+
+/**
+ * Copy a fixed-length string, with buffer overflow checking.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---strncpy-chk-1.html
+ */
+char *__strncpy_chk(char *dest, const char *src, size_t n, size_t destlen)
+{
+	assert(dest != NULL);
+	assert(src != NULL);
+	assert(destlen >= n);
+	if (dest < src) {
+		assert(dest + n <= src);
+	} else {
+		assert(src + n <= dest);
+	}
+
+	return strncpy(dest, src, n);
+}
+
+/**
+ * Duplicate a specific number of bytes from a string.
+ */
+char *__strndup(const char *s, size_t size)
+{
+	return strndup(s, size);
+}
+
+/**
+ * Extract token from string.
+ *
+ * The "global" definition of strsep in glibc, used when architecture dependent
+ * assembler versions aren't good enough.
+ */
+char *__strsep_g(char **stringp, const char *delim)
+{
+	return strsep(stringp, delim);
+}
+
+/**
+ * Split string into tokens.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---strtok-r-1.html
+ */
+char *__strtok_r(char *s, const char *delim, char **save_ptr)
+{
+	return strtok_r(s, delim, save_ptr);
+}
+
+void *memfrob(void *s, size_t n)
+{
+	unsigned char *c = s;
+
+	while (n--)
+		*c++ ^= 42;
+
+	return s;
+}
+
+char *strfry(char *s)
+{
+	static unsigned int seed;
+	size_t len = strlen(s);
+
+	if (!len)
+		return s;
+
+	seed += time(NULL) ^ getpid() ^ (uintptr_t) s;
+
+	for (size_t i = 0; i < len - 1; ++i) {
+		size_t j = rand_r(&seed) % (len - i) + i;
+		char t = s[i];
+		s[i] = s[j];
+		s[j] = t;
+	}
+
+	return s;
+}
diff --git a/src/libgcompat/sysctl.c b/src/libgcompat/sysctl.c
new file mode 100644
index 0000000..2e2fb4a
--- /dev/null
+++ b/src/libgcompat/sysctl.c
@@ -0,0 +1,29 @@
+#define _GNU_SOURCE
+#include <unistd.h> /* size_t */
+#include <sys/syscall.h>
+
+#ifdef SYS__sysctl
+
+struct __sysctl_args {
+	int *name;
+	int nlen;
+	void *oldval;
+	size_t *oldlenp;
+	void *newval;
+	size_t newlen;
+};
+
+int sysctl(int *name, int nlen, void *oldval, size_t *oldlenp, void *newval,
+           size_t newlen)
+{
+	struct __sysctl_args args = { .name = name,
+		                      .nlen = nlen,
+		                      .oldval = oldval,
+		                      .oldlenp = oldlenp,
+		                      .newval = newval,
+		                      .newlen = newlen };
+
+	return syscall(SYS__sysctl, &args);
+}
+
+#endif /* SYS__sysctl */
diff --git a/src/libgcompat/syslog.c b/src/libgcompat/syslog.c
new file mode 100644
index 0000000..b63a8a5
--- /dev/null
+++ b/src/libgcompat/syslog.c
@@ -0,0 +1,33 @@
+#define _GNU_SOURCE
+#include <assert.h> /* assert */
+#include <stdarg.h> /* va_list, va_start, va_end */
+#include <stddef.h> /* NULL */
+#include <syslog.h> /* vsyslog */
+
+void __vsyslog_chk(int priority, int flag, const char *format, va_list ap);
+
+/**
+ * Log a message, with stack checking.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---syslog-chk-1.html
+ */
+void __syslog_chk(int priority, int flag, const char *format, ...)
+{
+	va_list ap;
+
+	va_start(ap, format);
+	__vsyslog_chk(priority, flag, format, ap);
+	va_end(ap);
+}
+
+/**
+ * Log a message, with stack checking.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---vsyslog-chk-1.html
+ */
+void __vsyslog_chk(int priority, int flag, const char *format, va_list ap)
+{
+	assert(format != NULL);
+
+	vsyslog(priority, format, ap);
+}
diff --git a/src/libgcompat/unistd.c b/src/libgcompat/unistd.c
new file mode 100644
index 0000000..82d6a19
--- /dev/null
+++ b/src/libgcompat/unistd.c
@@ -0,0 +1,182 @@
+#define _GNU_SOURCE
+#include <assert.h> /* assert */
+#include <fcntl.h>  /* O_CREAT */
+#include <limits.h> /* NGROUPS_MAX */
+#include <stddef.h> /* NULL, size_t */
+#include <unistd.h> /* confstr, getcwd, getgroups, ... */
+
+#include "alias.h" /* alias */
+
+/**
+ * Get configurable variables, with buffer overflow checking.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---confstr-chk-1.html
+ */
+size_t __confstr_chk(int name, char *buf, size_t len, size_t buflen)
+{
+	assert(buf != NULL ? buflen >= len : len == 0);
+
+	return confstr(name, buf, len);
+}
+
+/**
+ * Get the pathname of the current working directory, with buffer overflow
+ * checking.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---getcwd-chk-1.html
+ */
+char *__getcwd_chk(char *buf, size_t len, size_t buflen)
+{
+	assert(buf != NULL);
+	assert(buflen >= len);
+
+	return getcwd(buf, len);
+}
+
+/**
+ * Get supplementary group IDs, with buffer overflow checking.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---getgroups-chk-1.html
+ */
+int __getgroups_chk(int gidsetsize, gid_t *grouplist, size_t listlen)
+{
+	assert(grouplist != NULL);
+	assert(listlen / sizeof(*grouplist) >= (size_t) gidsetsize);
+
+	return getgroups(gidsetsize, grouplist);
+}
+
+/**
+ * Get name of current host, with buffer overflow checking.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---gethostname-chk-1.html
+ */
+int __gethostname_chk(char *name, size_t namelen, size_t buflen)
+{
+	assert(name != NULL);
+	assert(buflen >= namelen);
+
+	return gethostname(name, namelen);
+}
+
+/**
+ * Get login name, with buffer overflow checking.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---getlogin-r-chk-1.html
+ */
+int __getlogin_r_chk(char *name, size_t namelen, size_t buflen)
+{
+	assert(name != NULL);
+	assert(buflen >= namelen);
+
+	return getlogin_r(name, namelen);
+}
+
+/**
+ * Get memory page size.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---getpagesize.html
+ */
+int __getpagesize(void)
+{
+	return getpagesize();
+}
+
+/**
+ * Get the process group ID for a process.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---getpgid-1.html
+ */
+pid_t __getpgid(pid_t pid)
+{
+	return getpgid(pid);
+}
+
+int __open_2(const char *path, int oflag)
+{
+	assert(!(oflag & O_CREAT));
+
+	return open(path, oflag);
+}
+alias(__open_2, __open64_2);
+
+/**
+ * Read from a file, with buffer overflow checking.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---pread-chk-1.html
+ */
+ssize_t __pread_chk(int fd, void *buf, size_t nbytes, off_t offset,
+                    size_t buflen)
+{
+	assert(buf != NULL);
+	assert(buflen >= nbytes);
+
+	return pread(fd, buf, nbytes, offset);
+}
+alias(__pread_chk, __pread64_chk);
+
+/**
+ * Read from a file, with buffer overflow checking.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---read-chk-1.html
+ */
+ssize_t __read_chk(int fd, void *buf, size_t nbytes, size_t buflen)
+{
+	assert(buf != NULL);
+	assert(buflen >= nbytes);
+
+	return read(fd, buf, nbytes);
+}
+
+/**
+ * Read the contents of a symbolic link, with buffer overflow checking.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---readlink-chk-1.html
+ */
+ssize_t __readlink_chk(const char *path, char *buf, size_t len, size_t buflen)
+{
+	assert(buf != NULL);
+	assert(buflen >= len);
+
+	return readlink(path, buf, len);
+}
+
+/**
+ * Get configurable system variables.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---sysconf.html
+ */
+long __sysconf(int name)
+{
+	return sysconf(name);
+}
+
+/**
+ * Find the pathname of a terminal, with buffer overflow checking.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---ttyname-r-chk-1.html
+ */
+int __ttyname_r_chk(int fd, char *name, size_t namelen, size_t buflen)
+{
+	assert(name != NULL);
+	assert(buflen >= namelen);
+
+	return ttyname_r(fd, name, namelen);
+}
+
+/**
+ * Test whether a process is in a group.
+ */
+int group_member(gid_t gid)
+{
+	gid_t groups[NGROUPS_MAX];
+	int ngroups = getgroups(NGROUPS_MAX, groups);
+
+	for (int i = 0; i < ngroups; ++i) {
+		if (groups[i] == gid) {
+			return 1;
+		}
+	}
+
+	return 0;
+}
diff --git a/src/libgcompat/utmp.c b/src/libgcompat/utmp.c
new file mode 100644
index 0000000..d044fd2
--- /dev/null
+++ b/src/libgcompat/utmp.c
@@ -0,0 +1,14 @@
+#include <stddef.h> /* NULL */
+#include <utmpx.h>   /* struct utmp */
+
+/**
+ * Get user accounting database entries.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib-getutent-r-3.html
+ */
+int getutent_r(struct utmp *buffer, struct utmp **result)
+{
+	/* musl does not implement getutent(). */
+	*result = NULL;
+	return -1;
+}
diff --git a/src/libgcompat/version.c b/src/libgcompat/version.c
new file mode 100644
index 0000000..1b7687c
--- /dev/null
+++ b/src/libgcompat/version.c
@@ -0,0 +1,28 @@
+#include <stddef.h> /* NULL */
+#include <stdlib.h> /* getenv */
+
+/**
+ * Get glibc release.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib-gnu-get-libc-version-1.html
+ */
+const char *gnu_get_libc_release(void)
+{
+	return "stable";
+}
+
+/**
+ * Get glibc version.
+ *
+ * LSB 5.0: LSB-Core-generic/baselib-gnu-get-libc-version-1.html
+ */
+const char *gnu_get_libc_version(void)
+{
+	char *ver = getenv("GLIBC_FAKE_VERSION");
+
+	if (ver == NULL) {
+		ver = "2.8";
+	}
+
+	return ver;
+}
diff --git a/src/libgcompat/wchar.c b/src/libgcompat/wchar.c
new file mode 100644
index 0000000..4ed7a7b
--- /dev/null
+++ b/src/libgcompat/wchar.c
@@ -0,0 +1,74 @@
+#include <assert.h> /* assert */
+#include <stdarg.h> /* va_list, va_start, va_end */
+#include <stddef.h> /* size_t */
+#include <wchar.h>  /* wchar_t, *wprintf */
+
+int __vswprintf_chk(wchar_t *s, size_t n, int flag, size_t slen,
+                    const wchar_t *format, va_list ap);
+
+/**
+ * Convert formatted wide-character output, with stack checking
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---swprintf-chk-1.html
+ */
+int __swprintf_chk(wchar_t *s, size_t n, int flag, size_t slen,
+                   const wchar_t *format, ...)
+{
+	int ret;
+	va_list ap;
+
+	va_start(ap, format);
+	ret = __vswprintf_chk(s, n, flag, slen, format, ap);
+	va_end(ap);
+
+	return ret;
+}
+
+/**
+ * Convert formatted wide-character output, with stack checking
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---vswprintf-chk-1.html
+ */
+int __vswprintf_chk(wchar_t *s, size_t n, int flag, size_t slen,
+                    const wchar_t *format, va_list ap)
+{
+	assert(s != NULL || n == 0);
+	assert(slen >= n);
+	assert(format != NULL);
+
+	return vswprintf(s, n, format, ap);
+}
+
+/**
+ * Copy a wide-character string, with buffer overflow checking
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---wcscpy-chk-1.html
+ */
+wchar_t *__wcscpy_chk(wchar_t *dest, const wchar_t *src, size_t n)
+{
+	size_t srclen;
+
+	assert(dest != NULL);
+	assert(src != NULL);
+	srclen = wcslen(src) + 1;
+	assert(n >= srclen);
+	if (dest < src) {
+		assert(dest + n <= src);
+	} else {
+		assert(src + n <= dest);
+	}
+
+	return wcscpy(dest, src);
+}
+
+/**
+ * Representation of the glibc internals of wcstol(3).
+ *
+ * LSB 5.0: LSB-Core-generic/baselib---wcstol-internal-1.html
+ */
+long int __wcstol_internal(const wchar_t *nptr, wchar_t **endptr, int base,
+                           int group)
+{
+	assert(group == 0);
+	return wcstol(nptr, endptr, base);
+}
